Ты опытный Dart/Flutter разработчик. 
Твоя задача внимательно проанализировать мой проект.
И предложить решения (пока без реализации просто обсуждение) по следующим задачам:





## ВАЖНО УЧЕСТЬ ПРИ РАЗРАБОТКЕ ИНСТРУКЦИЯ ДЛЯ ИИ РАЗРАБОТЧИКА

* **ВАЖНО ПРЕДЛАГАТЬ ПОПОЛНЯТЬ ДАННЫЙ Список технических проблем при столкновении с проблемами:** пополнять список ограничений и «подводных камней», выявленных в ходе разработки, которые необходимо знать следующему разработчику, чтобы не сломать текущую логику.

### 0. ВАЖНО СОХРАНЯТЬ ТО ЧТО УЖЕ РАБОТАЕТ
* **ВАЖНО:** Сохраняем то что уже работает.

### 1. Архитектура списка (Flattened Tree)
* **Проблема:** Стандартный `ReorderableListView` во Flutter не умеет работать с вложенными структурами (деревом виджетов). При попытке сделать рекурсивный список ломается Drag & Drop.
* **Реализация:** Используется **плоский список** (`_buildHierarchicalList` в UI). Вложенность — визуальная иллюзия, создаваемая через `margin` (отступ слева).
* **Риск:** При изменении логики рендеринга нельзя переходить на рекурсивные вызовы виджетов для детей — перестанет работать перетаскивание. Родитель (`parentId`) вычисляется математически на основе соседей при событии `onReorder`.

### 2. RuStore Update SDK
* **Проблема:** Официальная документация устарела. Методов `install()` или `completeUpdate()` больше не существует в актуальной версии плагина.
* **Нюанс:** Метод `RustoreUpdateClient.download()` сам инициирует нативный интент установки APK.
* **Баг SDK:** Иногда метод возвращает код (например, `0`), но установка не начинается (тихая отмена или сбой).
* **Решение:** Обязательно проверять возвращаемое значение `.then((value))`. Если `value != -1` (в Android это `RESULT_OK`), необходимо принудительно открывать ссылку на магазин через `url_launcher` как фолбек.

### 3. Краш UI на Android (BorderStyle)
* **Проблема:** Использование `BorderStyle.dashed` в `BoxDecoration` приводит к нативному крашу приложения на некоторых версиях Android при отрисовке.
* **Ограничение:** Использовать только `BorderStyle.solid`. Пунктирные линии нужно реализовывать через кастомные пэйнтеры или SVG, но не через стандартный border контейнера.

### 4. Конфликт сортировки и статусов («Срочные всегда сверху»)
* **Проблема:** Пользователь может попытаться перетащить «Обычную» задачу (серую) выше «Срочной» (красной) в плоском списке.
* **Логика:** В коде зашит механизм **авто-конвертации**. Если обычная задача перетаскивается в зону срочных (выше границы раздела), она *автоматически* меняет свойство `urgency` на `2` и перекрашивается.
* **Риск:** Если следующий разработчик уберет эту проверку в `_onReorder`, список станет визуально "рваным" (смесь красных и белых задач), что нарушит концепцию "Скрижалей".

### 5. Конфликт жестов (Tap vs DoubleTap)
* **Проблема:** Виджет `InkWell` / `GestureDetector` захватывает `onTap` (открытие папки) раньше, чем `onDoubleTap` (редактирование), из-за чего редактирование может не срабатывать.
* **Реализация:** Логика разделена по индексам табов:
    * **Tab 1 (Активные):** Двойной клик имеет приоритет и открывает диалог.
    * **Tab 0 и 2 (Архивы):** Редактирование запрещено, работает только одиночный клик для открытия папки.
* **Риск:** Нельзя просто объединять эти обработчики, иначе в архивах появится возможность редактировать удаленные задачи, а в активном — перестанут открываться диалоги.

### 6. Оптимизация анимации (VisibilityDetector)
* **Проблема:** Анимация мигания (подсветка новой задачи) запускалась в момент создания виджета. Если задача добавлялась в конец длинного списка (вне экрана), таймер отрабатывал впустую, и пользователь не видел эффекта, доскроллив туда.
* **Решение:** Используется `visibility_detector`. Таймер запускается строго по условию `visibleFraction > 0.5`. Не удалять эту обертку.

### 7. Специфика "Детей" (Subtasks) в архивах
* **Проблема:** В "Мусорке" и "Выполненном" ненужно свайпать подзадачи по отдельности, так как они логически привязаны к родителю.
* **Ограничение:** В `_buildTaskItem` стоит жесткая блокировка: если задача имеет `parentId` и мы не в главном табе — `Dismissible` (свайп) не создается. Разрешено удалять/восстанавливать только родителя целиком.

### 8. Целостность данных Hive (Orphans)
* **Проблема:** Hive (NoSQL) не имеет каскадного удаления.
* **Риск:** Удаление папки через простой `delete()` оставит подзадачи-призраки с `parentId`.
* **Решение:** Использовать метод репозитория `permanentlyDelete`, который сначала чистит детей, потом родителя.

### 9. Реактивность UI (ValueListenable)
* **Проблема:** Данные могут меняться фоново (бэкап, сервис).
* **Решение:** Использовать `ValueListenableBuilder` для списка задач.
* **Ограничение:** Минимизировать ручные вызовы `setState` для обновления данных списка, полагаться на реактивность Hive.

### 10. Атомарность Бэкапов
* **Проблема:** Бэкап — это ручной дамп JSON.
* **Риск:** При изменении модели `Task` старые бэкапы могут сломать приложение при восстановлении.
* **Ограничение:** При добавлении полей в `Task` обязательно обновлять `toJson` и обеспечивать обратную совместимость.

### 11. НЕ ПИСАТЬ КОММЕНТАРИИ В КОДЕ
* **ЗАПРЕЩЕНО:** В коде писать комментарии.

### 12. Логика "Одного фокуса" (UI)
* **Логика:** При открытии папки или разворачивании задачи, все остальные элементы должны принудительно сворачиваться. На экране всегда должен быть активен только один элемент контекста.

### 13. Виртуальные элементы в FlatList
* **Реализация:** Для группировки выполненных подзадач используются виртуальные Task-объекты (кнопки с точками), которые не сохраняются в Hive, а генерируются на лету в `_buildHierarchicalList`.

### 14. Стабильность верстки (Jitter Effect)
* **Проблема:** При динамическом добавлении обводки (например, подсветка дубликата или фокуса) элемент "дергается", так как `Border` добавляет толщину к размеру виджета.
* **Ограничение:** Если элемент предполагает подсветку, он должен **всегда** иметь прозрачную обводку той же толщины (`Border.all(color: Colors.transparent, width: 3)`). При подсветке меняется только цвет (`color: Colors.red`). Менять `width` с 0 на 3 запрещено.

### 15. Стиль приложения и приемственность стилей
* **Реализация:** Для поддержания единого стиля в приложении следует при нововведениях учитывать стилистику шрифты цвета и т.п. и не менять без просьбы то что уже сделано.